<!DOCTYPE html>
<html>
<head>
  <title>Hartslagmeter</title>
  <style>
    canvas
    {
      background: #eee;
      border-radius: 15px;
    }
  </style>
</head>
<body>
  <h1>Hartslagmeter</h1>
  v.28.12.23.12.00
  <div id="console"></div>
  <audio id="beep" src="beep.wav"></audio>
  <canvas id="history" width=400 height=200></canvas>
  <button class="switch">Toggle Flash</button>
  <video id="video" width="400" height="300" autoplay></video>
  <div id="measurement"></div>
  <div id="status"></div>

  <script>
    let status = "waiting for camera";
    const consoleOutput = document.getElementById("console");
    const log = function (msg) {
      consoleOutput.innerText = `${consoleOutput.innerText}\n${msg}`;
      console.log(msg);
    };

    const SUPPORTS_MEDIA_DEVICES = 'mediaDevices' in navigator;

    if (SUPPORTS_MEDIA_DEVICES) {
      navigator.mediaDevices.enumerateDevices().then(devices => {
        const cameras = devices.filter((device) => device.kind === 'videoinput');

        if (cameras.length === 0) {
          log('No camera found on this device.');
        }

        navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
          }
        }).then(stream => {
          const track = stream.getVideoTracks()[0];
          const imageCapture = new ImageCapture(track);

          const video = document.getElementById('video');
          video.srcObject = stream;

          imageCapture.getPhotoCapabilities().then(capabilities => {
            const btn = document.querySelector('.switch');
            const torchSupported = !!capabilities.torch || (
              'fillLightMode' in capabilities &&
              capabilities.fillLightMode.length != 0 &&
              capabilities.fillLightMode != 'none'
            );

            if (torchSupported) {
              let torch = false;
              btn.addEventListener('click', function (e) {
                try {
                  track.applyConstraints({
                    advanced: [{
                      torch: (torch = !torch)
                    }]
                  });
                } catch (err) {
                  log(err);
                }
                status = "waiting for red";
                loop();
              });
            } else {
              log("No torch found");
              // continue anyway for testing..
              status = "waiting for red";
              loop();
            }
          }).catch(log);
        }).catch(log);
      }).catch(log);
    }
    var canvas=document.getElementById("history");
    var ctx=canvas.getContext("2d");
    var measurement_str = "",min,max,calibrate=0,lastMeasurements = [],rawMeasurements = [];
    function adjustRange(m)
    {
        rawMeasurements.push(m);
        if(rawMeasurements.length>35)rawMeasurements.shift();
        min=10000;
        max=-10000;
        for(var i=0;i<lastMeasurements.length;i++)
        {
           if (rawMeasurements[i]<min) min=rawMeasurements[i];
          if (rawMeasurements[i]>max) max=rawMeasurements[i];
        }
        // save the adjusted one
        lastMeasurements.push((m-min)/(max-min));
        // tickertape and display it..
        if(lastMeasurements.length>400)lastMeasurements.shift();
        ctx.clearRect(0,0,400,200);
        ctx.strokeStyle="#888";
        ctx.beginPath();
        ctx.moveTo(0,100);
        ctx.lineTo(400,100);
        ctx.stroke();
        ctx.strokeStyle="#800";
        ctx.beginPath();
        for(var i=0;i<lastMeasurements.length;i++)
        {
          var a=lastMeasurements[i]-0.5;
          //console.log(a);
          if(i==0) ctx.moveTo(i,100+a*100);
          else ctx.lineTo(i,100+a*100);
        }
        ctx.stroke();
    }

    function loop() {
      document.getElementById("status").innerHTML = status +" - "+ (Date.now()%1000);
      switch (status) {
        case "waiting for red":
          var col = getAverageColor(video, { x: 0, w: video.width, y: 0, h: video.height });
          var greenblue = col.g + col.b;
          if (col.r > greenblue )
          {
            calibrate=0
            status = "calibrating";
          }
          console.log(col);
          break;
        case "calibrating":
          calibrate++;
          if(calibrate<100)
          {
            min=10000; // wait a little, then calibrate.. to make things rest.
            max=-10000;
            measurement_str = "calibrating..." ;
          }
          var col = getAverageColor(video, { x: 0, w: video.width, y: 0, h: video.height });
          if (min>col.r) min=col.r;
          if (col.r>max) max=col.r;
          // finding min and max for a while.
            document.getElementById("measurement").innerHTML = measurement_str;
            measurement_str = ""+Math.floor(100*calibrate/200)+"%" ;
          if(calibrate>200)
          {
            status="measuring";
            measurement_str ="";
          }
        break;
        case "measuring":
            var col = getAverageColor(video, { x: 0, w: video.width, y: 0, h: video.height });
            adjustRange(col.r);
            console.log(min, col.r,max);
            var hart=Math.floor(10*(col.r-min)/(max-min));
            console.log(col);
            measurement_str += " " + hart;
            if (measurement_str.length > 250) {
              // tickertape it..
              measurement_str = measurement_str.substr(2, measurement_str.length);
            }
            document.getElementById("measurement").innerHTML = measurement_str;
          break;
      }
      window.requestAnimationFrame(loop);
    }

    function getAverageColor(canvas, area) {
      // Create a 1x1 pixel canvas
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = 1;
      tempCanvas.height = 1;
      const tempCtx = tempCanvas.getContext('2d');

      // Get the area to be copied
      const x = area.x || 0;
      const y = area.y || 0;
      const width = area.w || canvas.width;
      const height = area.h || canvas.height;

      // Draw the specified area onto the 1x1 canvas
      tempCtx.drawImage(canvas, x, y, width, height, 0, 0, 1, 1);

      // Get the pixel data of the 1x1 canvas
      const pixelData = tempCtx.getImageData(0, 0, 1, 1).data;

      // Calculate the average color (RGBA values)
      const averageColor = {
        r: pixelData[0],
        g: pixelData[1],
        b: pixelData[2],
        a: pixelData[3] / 255 // Normalize alpha value (0-1 range)
      };

      return averageColor;
    }
  </script>
</body>
</html>
